\section{La syntaxe de Python}

\subsection{Les blocs}
\begin{frame}[fragile]
  \frametitle{Syntaxe - Les blocs}
  \begin{itemize}
    \item En Python le code est regroupé en bloc.
    \item Les blocs sont définis par:
    \begin{itemize}
      \item La ligne précédente commence par un mot clef, se termine par ':'
      \item Leur niveau d'indentation.
    \end{itemize}
    \item Les mots clefs de définition de blocs : \alert<1->{if}, \alert<2->{while}, \alert<3->{for}, \alert<4->{def}, \alert<5->{class}, \alert<6->{with}
  \end{itemize}

\end{frame}

\subsection{Les instructions}
\begin{frame}
  \frametitle{Syntaxe - Les instructions}
  \begin{itemize}
    \item<1-> Au sein d'un bloc, on sépare généralement chaque instruction par un retour à la ligne.
    \item<2-> La ligne suivante, si elle fait partie du même bloc, doit avoir la même indentation.
    \item<3-> Il est aussi possible, bien que déconseillé, de mettre plusieurs instructions sur une ligne
    \begin{itemize}
      \item<4-> Il faut alors les séparer par ';'
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Les déclarations conditionnelles}
\begin{frame}[fragile]
  \frametitle{Déclarations conditionnelles - Syntaxe de base}
  \begin{lstlisting}
if condition1:
    declaration1
elif condition2:
    declaration2
else:
    declaration3
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Déclarations conditionnelles - Exemple}
  \begin{lstlisting}
my_str = "word"
if 1 > 2:
    print "1>2"
elif my_str == "word":
    print "my_str = word"
else:
    print "else"
  \end{lstlisting}

  \begin{beamercolorbox}{terminal}
  \begin{semiverbatim}
 \$ python example.py
 \uncover<2>{my_str = word} \end{semiverbatim}
  \end{beamercolorbox}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe - Les conditions}
  \begin{itemize}
    \item les comparaisons
  \end{itemize}
  \begin{beamercolorbox}{terminal}
  \begin{semiverbatim}
\uncover<1->{ In [1]: (1 == 2, 1 < 2, 2 < 1, 1 != 2)}
\uncover<1->{ Out[1]: (False, True, False, True)}

\uncover<2>{ In [2]: my_str = "hello"}
\uncover<2>{ In [2]: (my_str == "hello", my_str > "helln",
    ...: my_str < "hellq")}
\uncover<2>{ Out[2]: (True, True, True)}\end{semiverbatim}
    \end{beamercolorbox}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe - Les conditions}
  \begin{itemize}
    \item les opérateurs booléens
  \end{itemize}
  \begin{beamercolorbox}{terminal}
  \begin{semiverbatim}
 In [1]: not True and False or not False
 Out[1]: True\end{semiverbatim}
  \end{beamercolorbox}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe - Les conditions}
  \begin{itemize}
    \item par extension, certains objets vides sont équivalent à False
  \end{itemize}
  \begin{beamercolorbox}{terminal}
  \begin{semiverbatim}
 In [1]: my_str = ""
 In [1]: if not my_str:
    ...:     print "False"
 False\end{semiverbatim}
  \end{beamercolorbox}
\end{frame}

\subsection{Les boucles}
\begin{frame}[fragile]
  \frametitle{Syntaxe - Les boucles}
  \begin{itemize}
  \item for : répéter tant qu'il y a des éléments dans un ensemble
  \item while : répéter tant qu'une condition reste vraie
  \end{itemize}

Compatible : break/continue (comme dans les autres langages)
\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe de for}
  \begin{lstlisting}
for item in <generator>:
    code ...
  \end{lstlisting}
Examples de générateur :
  \begin{itemize}
  \item ("item1", "item2", "item3")
  \item range(5) ou (0, 1, 2, 3, 4)
  \item xrange(5)
  \item n'importe quel objet ayant la méthode next()
  \end{itemize}
\end{frame}

\subsection{Les méthodes/fonctions}
\begin{frame}[fragile]
  \frametitle{Syntaxe - Les méthodes/fonctions}
  \begin{itemize}
    \item En Python, la signature d'une méthode n'inclut pas le type retourné.
    \item Les arguments passés peuvent être des paramètres ou des arguments nommés.
    \item Le mot clef utilisé est {\bf def}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe de def}
Avec des paramètres :
  \begin{lstlisting}
def nom_de_methode(arg1, arg2, arg3):
    code ...
  \end{lstlisting}
Avec des arguments nommés :
  \begin{lstlisting}
def nom_de_methode(arg1=True, arg2=3):
    code ...
  \end{lstlisting}
Fonction variadique :
  \begin{lstlisting}
def nom_de_methode(*args, **kwargs):
    code ...
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fonctions - Valeur de retour}
Pour que la fonction retourne une valeur, il faut utiliser le mot clef {\bf return}.
  \begin{lstlisting}
def nom_de_methode(arg1, arg2, arg3):
    code ...
    return value
  \end{lstlisting}

La signature n'incluant pas le type retourné, il est possible de retourner des types d'objets différents selon les contextes d'utilisation, mais dans la pratique c'est une mauvaise idée.
\end{frame}

\subsection{Les classes}
\begin{frame}[fragile]
  \begin{lstlisting}
class nom_de_classe:
    def __init__(self):
        code...

    def methode_1(self):
        code...
  \end{lstlisting}
\end{frame}

\section{Autre}
% ici: des infos sur les namespaces, les objets
