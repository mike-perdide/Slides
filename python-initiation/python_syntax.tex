\section{La syntaxe de Python}

\subsection{Les blocs}
\begin{frame}[fragile]
  \frametitle{Syntaxe - Les blocs}
  \begin{itemize}
    \item En Python le code est regroupé en bloc.
    \item Les blocs sont définis par:
    \begin{itemize}
      \item La ligne précédente commence par un mot clef, se termine par ':'
      \item Leur niveau d'indentation (par convention, 4 espaces par indentation)
    \end{itemize}
    \item Les mots clefs de définition de blocs : \alert<1->{if}, \alert<2->{while}, \alert<3->{for}, \alert<4->{def}, \alert<5->{class}, \alert<6->{with}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe - Les blocs, exemple}
  \begin{lstlisting}
import sys
from PyQt4.QtGui import QApplication
from gitbuster.main_window import MainWindow, \
                         select_git_directory
def main():
    app = QApplication(sys.argv)
    filepath = select_git_directory()
    if filepath:
        a = MainWindow(directory=filepath, debug=True)
        a.show()
        sys.exit(app.exec_())
    else:
        sys.exit(1)
  \end{lstlisting}
\end{frame}

\subsection{Les instructions}
\begin{frame}
  \frametitle{Syntaxe - Les instructions}
  \begin{itemize}
    \item<1-> Au sein d'un bloc, on sépare généralement chaque instruction par un retour à la ligne.
    \item<2-> La ligne suivante, si elle fait partie du même bloc, doit avoir la même indentation.
    \item<3-> Il est aussi possible, bien que déconseillé, de mettre plusieurs instructions sur une ligne
    \begin{itemize}
      \item<4-> Il faut alors les séparer par ';'
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Les déclarations conditionnelles}
\begin{frame}[fragile]
  \frametitle{Déclarations conditionnelles - Syntaxe de base}
  \begin{lstlisting}
if condition1:
    declaration1
elif condition2:
    declaration2
else:
    declaration3
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Déclarations conditionnelles - Exemple}
  \begin{lstlisting}
my_str = "word"
if 1 > 2:
    print "1>2"
elif my_str == "word":
    print "my_str = word"
else:
    print "else"
  \end{lstlisting}

  \begin{beamercolorbox}{terminal}
  \begin{semiverbatim}
 \$ python example.py
 \uncover<2>{my_str = word} \end{semiverbatim}
  \end{beamercolorbox}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe - Les conditions}
  \begin{itemize}
    \item les comparaisons
  \end{itemize}
  \begin{ipython}
    \ipinwrap{1}{0}{(1 == 2, 1 < 2, 2 < 1, 1 != 2)}
    \ipouwrap{2}{0}{(False, True, False, True)}
    \ipinwrap{3}{1}{my_str = "hello"}
    \ipinwrap{4}{2}{(my_str == "hello", }
    \ipincontwrp{4}{my_str > "helln",}
    \ipincontwrp{4}{my_str < "hellq")}
    \ipouwrap{5}{2}{(True, True, True)}
  \end{ipython}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe - Les conditions}
  \begin{itemize}
    \item les opérateurs booléens
  \end{itemize}
  \begin{beamercolorbox}{terminal}
  \begin{semiverbatim}
 In [1]: not True and False or not False
 Out[1]: True\end{semiverbatim}
  \end{beamercolorbox}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe - Les conditions}
  \begin{itemize}
    \item par extension, certains objets vides sont équivalent à False
  \end{itemize}
  \begin{beamercolorbox}{terminal}
  \begin{semiverbatim}
 In [1]: my_str = ""
 In [1]: if not my_str:
    ...:     print "False"
 False\end{semiverbatim}
  \end{beamercolorbox}
\end{frame}

\subsection{Les boucles}
\begin{frame}[fragile]
  \frametitle{Syntaxe - Les boucles}
  \begin{itemize}
  \item for : répéter tant qu'il y a des éléments dans un ensemble
  \item while : répéter tant qu'une condition reste vraie
  \end{itemize}

Compatible : break/continue (comme dans les autres langages)
\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe de for}
  \begin{lstlisting}
for item in <generator>:
    code ...
  \end{lstlisting}
Examples de générateur :
  \begin{itemize}
  \item ("item1", "item2", "item3")
  \item range(5) ou (0, 1, 2, 3, 4)
  \item xrange(5)
  \item n'importe quel objet ayant la méthode next()
  \end{itemize}
\end{frame}

\subsection{Les méthodes/fonctions}
\begin{frame}[fragile]
  \frametitle{Syntaxe - Les méthodes/fonctions}
  \begin{itemize}
    \item En Python, la signature d'une méthode n'inclut pas le type retourné.
    \item Les arguments passés peuvent être des paramètres ou des arguments nommés.
    \item Le mot clef utilisé est {\bf def}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe de def}
Avec des paramètres :
  \begin{lstlisting}
def nom_de_methode(arg1, arg2, arg3):
    code ...
  \end{lstlisting}
Avec des arguments nommés :
  \begin{lstlisting}
def nom_de_methode(arg1=True, arg2=3):
    code ...
  \end{lstlisting}
Fonction variadique :
  \begin{lstlisting}
def nom_de_methode(*args, **kwargs):
    code ...
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fonctions - Valeur de retour}
Pour que la fonction retourne une valeur, il faut utiliser le mot clef {\bf return}.
  \begin{lstlisting}
def nom_de_methode(arg1, arg2, arg3):
    code ...
    return value
  \end{lstlisting}

La signature n'incluant pas le type retourné, il est possible de retourner des types d'objets différents selon les contextes d'utilisation, mais dans la pratique c'est une mauvaise idée.
\end{frame}

\subsection{Les classes}
\begin{frame}[fragile]
  \frametitle{Syntaxe - Les classes}
  \begin{itemize}
    \item<1-> Python, langage orienté objet, permet la définition de nouveaux types d'objets grâce au mot clef {\bf class}.
    \item<2-> Les classes comportent une méthode \verb=__init__= ("constructeur").
    \item<3-> Toutes les méthodes d'une classes prennent pour premier argument \verb=self= (par convention).
    \begin{itemize}
      \item<3-> \verb=self= est l'objet sur lequel est appelé la méthode.
    \end{itemize}
    \item<4-> Les classes peuvent dériver de classes parentes et hériter de leurs attributs.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe de class}
  \begin{lstlisting}
class nom_de_classe(classe_parente):
    def __init__(self, arg1):
        classe_parente.__init__(self)

        self._attr1 = arg1

    def methode_1(self, arg1):
        code...
  \end{lstlisting}
\end{frame}

\section{Autre}
% ici: des infos sur les namespaces, les objets
