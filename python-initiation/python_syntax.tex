\section{La syntaxe de Python}

\subsection{Les blocs de code}
\begin{frame}[fragile]
  \frametitle{Syntaxe - Les blocs de code, ou suites}
  \begin{description}
  \item[L'indentation du code] est par convention un multiple de 4 espaces.
  \item[Un bloc de code] est constitué de lignes de code dont le niveau d'indentation/d'imbrication est égal ou supérieur à celui de sa première ligne.
  \item[Des sous-blocs] sont donc éventuellement présents au sein d'un bloc de code, en tant que membres de déclarations composées.
  \end{description}
\end{frame}

\subsection{Les déclarations composées}
\subsubsection{Définition}
\begin{frame}[fragile]
  \frametitle{Syntaxe - Les déclarations composées : définition}
  \begin{description}
  \item[Les déclarations composées] sont introduites par une déclaration elle-même composée
  \begin{itemize}
      \item d'un mot clef parmi «\hlcmd{if}», «\hlcmd{for}», «\hlcmd{def}»~\ldots
      \item suivi par des paramètres
      \item conclue par «\hlcmd{:}»
  \end{itemize}
  \item[Un ou plusieurs blocs d'instruction] sont contenus dans une déclaration composée.
  \end{description}
\end{frame}

\subsubsection{Exemple}
\begin{frame}[fragile]
  \frametitle{Syntaxe - Les déclarations composées : l'exemple de if}
  \emph{Le «\texttt{if}» tel que dans la grammaire:}\\
  \begin{beamercolorbox}{documentation}
  \small{\verb|if_stmt:|} \\
  \small{\verb|    'if' test ':' suite|} \\
  \small{\verb|    ('elif' test ':' suite)*|} \\
  \small{\verb|    ['else' ':' suite]|}
  \end{beamercolorbox}
  \begin{lstlisting}
if 2 + 2 == 5 :
    print "Voila",
    print "de tres grandes valeurs de 2."
elif 1 > 1:
    print "1 s'est toujours cru ",
    print "superieur."
else:
    print "Un monde banal ",
    print "et ennuyeux."
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe - Les déclarations composées : l'exemple de if}
  \begin{beamercolorbox}{terminal}
\scriptsize\begin{verbatim}$ python
Python 2.6.6 (r266:84292, Dec 26 2010, 22:31:48)
[GCC 4.4.5] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> if 2 + 2 == 5 :
...     print "Voila",
...     print "de tres grandes valeurs de 2."
... elif 1 > 1:
...     print "1 s'est toujours cru ",
...     print "superieur."
... else:
...     print "Un monde banal ",
...     print "et ennuyeux."
...
Un monde banal  et ennuyeux.
>>>
\end{verbatim}
  \end{beamercolorbox}
\end{frame}

\subsubsection{Liste brute}
\begin{frame}[fragile]
  \frametitle{Syntaxe - Les déclarations composées : liste}
Liste fournie pour référence, ne pas essayer de tout comprendre maintenant !
\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe - Les déclarations composées : liste brute}
\begin{figure}
  \begin{beamercolorbox}{documentation}
\scriptsize\begin{verbatim}
if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
while_stmt: 'while' test ':' suite ['else' ':' suite]
for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite]
try_stmt: ('try' ':' suite
           ((except_clause ':' suite)+
            ['else' ':' suite]
            ['finally' ':' suite] |
           'finally' ':' suite))
with_stmt: 'with' with_item (',' with_item)*  ':' suite
with_item: test ['as' expr]
# NB compile.c makes sure that the default except clause is last
except_clause: 'except' [test [('as' | ',') test]]
\end{verbatim}
  \end{beamercolorbox}
\caption{http://docs.python.org/reference/grammar.html}
\end{figure}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe - Les déclarations composées : liste traduite}
Soit grosso modo, en français
\small\begin{tabular}{|l|l|l|}
\hline
mot clef & rôle & suivi de / variante \\
\hline \hline
\texttt{if} & condition & suivi de \texttt{0..* elif}, \texttt{0..1 else}\\ \hline
\texttt{while} & boucle "tant que" & suivi de \texttt{0..1 else}\\ \hline
\texttt{for} & itération sur éléments & suivi de \texttt{0..1 else}\\ \hline
\texttt{try} & fournit un mécanisme & suivi de \texttt{finally} \\
 & de gestion des &  ou de \texttt{1..* except}, \\
 & exceptions & \texttt{0..1 finally}, \texttt{0..1 else}\\ \hline
\texttt{with} & définition de contexte & \\ \hline
\texttt{def} & définition de fonction & variante décorée \\ \hline
\texttt{class} & définition de classe & variante décorée \\ \hline
\end{tabular}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Syntaxe - Les blocs ou suites : exemple complet}
  \begin{lstlisting}
import sys
from PyQt4.QtGui import QApplication
from gitbuster.main_window import MainWindow, \
                         select_git_directory
def main():
    app = QApplication(sys.argv)
    filepath = select_git_directory()
    if filepath:
        a = MainWindow(directory=filepath, debug=True)
        a.show()
        sys.exit(app.exec_())
    else:
        sys.exit(1)
  \end{lstlisting}
\end{frame}

\subsection{Les instructions}
\begin{frame}
  \frametitle{Syntaxe - Les instructions}
  \begin{itemize}
    \item<1-> Au sein d'un bloc, on sépare généralement chaque instruction par un retour à la ligne.
    \item<2-> La ligne suivante, si elle fait partie du même bloc, doit avoir la même indentation.
    \item<3-> Il est aussi possible, bien que déconseillé, de mettre plusieurs instructions sur une ligne
    \begin{itemize}
      \item<4-> Il faut alors les séparer par ';'
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Les déclarations conditionnelles}
\begin{frame}[fragile]
  \frametitle{Déclarations conditionnelles - Syntaxe de base}
  \begin{lstlisting}
if condition1:
    declaration1
elif condition2:
    declaration2
else:
    declaration3
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Déclarations conditionnelles - Exemple}
  \begin{lstlisting}
my_str = "word"
if 1 > 2:
    print "1>2"
elif my_str == "word":
    print "my_str = word"
else:
    print "else"
  \end{lstlisting}

  \begin{beamercolorbox}{terminal}
  \begin{semiverbatim}
 \$ python example.py
 \uncover<2>{my_str = word} \end{semiverbatim}
  \end{beamercolorbox}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe - Les conditions}
  \begin{itemize}
    \item les comparaisons
  \end{itemize}
  \begin{ipython}
    \ipinpt{(1 == 2, 1 < 2, 2 < 1, 1 != 2)}
    \ipoutp{(False, True, False, True)}
    \ipinpt{my_str = "hello"}
    \ipinpt{(my_str == "hello",}
    \ipcont{ my_str > "helln", }
    \ipcont{ my_str < "hellq") }
    \ipoutp{(True, True, True)}
  \end{ipython}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe - Les conditions}
  \begin{itemize}
    \item les opérateurs booléens
  \end{itemize}
  \begin{ipython}
    \ipinpt{not True and False or not False}
    \ipoutp{True}
  \end{ipython}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe - Les conditions}
  \begin{itemize}
    \item par extension, certains objets vides sont équivalent à False
  \end{itemize}
  \begin{ipython}
    \ipinpt{my_str = ""}
    \ipinpt{if not my_str:}
    \ipcont{    print "False"}
    \ipoutp{False}
  \end{ipython}
\end{frame}

\subsection{Les boucles}
\begin{frame}[fragile]
  \frametitle{Syntaxe - Les boucles}
  \begin{itemize}
    \item for : répéter tant qu'il y a des éléments dans un ensemble
    \item while : répéter tant qu'une condition reste vraie
  \end{itemize}

  Compatible : break/continue (comme dans les autres langages)
\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe de for}
  \begin{lstlisting}
for item in <generator>:
    code ...
  \end{lstlisting}
Examples de générateur :
  \begin{itemize}
  \item ("item1", "item2", "item3")
  \item range(5) ou (0, 1, 2, 3, 4)
  \item xrange(5)
  \item n'importe quel objet ayant la méthode next()
  \end{itemize}
\end{frame}

\subsection{Les méthodes/fonctions}
\begin{frame}[fragile]
  \frametitle{Syntaxe - Les méthodes/fonctions}
  \begin{itemize}
    \item En Python, la signature d'une méthode n'inclut pas le type retourné.
    \item Les arguments passés peuvent être des paramètres et/ou des arguments nommés.
    \item Le mot clef utilisé est {\bf def}.
    \item TODO: parler des scopes. cf http://www.network-theory.co.uk/docs/pytut/PythonScopesandNameSpaces.html
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe de def}
Avec des paramètres :
  \begin{lstlisting}
def nom_de_methode(arg1, arg2, arg3):
    code ...
  \end{lstlisting}
Avec des arguments nommés :
  \begin{lstlisting}
def nom_de_methode(arg1=True, arg2=3):
    code ...
  \end{lstlisting}
Fonction variadique :
  \begin{lstlisting}
def nom_de_methode(*args, **kwargs):
    code ...
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fonctions - Valeur de retour}
Pour que la fonction retourne une valeur, il faut utiliser le mot clef {\bf return}.
  \begin{lstlisting}
def nom_de_methode(arg1, arg2, arg3):
    code ...
    return value
  \end{lstlisting}

La signature n'incluant pas le type retourné, il est possible de retourner des types d'objets différents selon les contextes d'utilisation, mais dans la pratique c'est une mauvaise idée.
\end{frame}

\subsection{Les classes}
\begin{frame}[fragile]
  \frametitle{Syntaxe - Les classes}
  \begin{itemize}
    \item<1-> Python, langage orienté objet, permet la définition de nouveaux types d'objets grâce au mot clef {\bf class}.
    \item<2-> Les classes comportent une méthode \verb=__init__= ("constructeur").
    \item<3-> Toutes les méthodes d'une classes prennent pour premier argument \verb=self= (par convention).
    \begin{itemize}
      \item<3-> \verb=self= est l'objet sur lequel est appelé la méthode.
    \end{itemize}
    \item<4-> Les classes peuvent dériver de classes parentes et hériter de leurs attributs.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Syntaxe de class}
  \begin{lstlisting}
class nom_de_classe(classe_parente):
    def __init__(self, arg1):
        classe_parente.__init__(self)

        self._attr1 = arg1

    def methode_1(self, arg1):
        code...
  \end{lstlisting}
\end{frame}

\section{Autre}
% ici: des infos sur les namespaces, les objets
